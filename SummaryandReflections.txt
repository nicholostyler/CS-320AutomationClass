      Before I began unit testing for the contact and task classes, I wrote down exactly what the client was looking for and made sure every point was accounted for. The overarching approach that I took with testing was to make sure that every requirement was satisfied. This also included using error checking outside of the unit tests such as throwing errors when there was code outside of the specified requirements. 
	One of the specific ways I adhered to the software requirements was in the task class where it specifies that the individual member variables cannot be more than a certain length. In the TaskTest class for instance, I made individual test methods for every requirement, one for the id, name, and description. In these methods I then used an assert that returns true if the method throws a specific exception. This means it would fulfill the requirement of making sure an error is thrown if the variable is too long or is null.
	JUnit tests are a good way of letting me know that a class and more specifically a method prevents the errors how you expect them too. The way these unit tests let you know that they were affective is if they behave how you expect them to. For instance, we want to make sure we are not getting null values or long strings for our variables, so we have a unit test for every one of those scenarios.
	The coverage of my code through JUnit tests were high because I focused on having a one-to-one testing of my code for each requirement in the business plan. Since my methods are fairly aligned already with the requirements, having a unit test for each of the methods brings my coverage close to 100%. Having 100% coverage means that each of my methods is being tested for their quality and how well they work.
	I ensured that my code was technically sound from the many methods in my unit tests that cover all the requirements needed by the client. One of the ways is with the method that tests if you get the correct information back from creating the task class. Walking through the method, we have an object initialization with standard error checking on the variables inside the constructor. Then, we assert all the member variables to see if they are in fact returning what they should.
	A way that my tests are efficient is that they rely on a few lines to do what needs to be done. They also rely on simple and quick algorithms for searching through and iterating over the arraylist in places like the task service class. For instance, in the testing method that tests if a description is too long, it is just a couple lines to test if an exception is thrown and an error occurs. 
      The software testing technique that I used mostly in the milestones was unit testing. This is used as it is most often the first line of defense when testing your code. It involves physically writing code to build objects and prove that it will either be or not be a certain value. For instance, if I wanted to see if a method threw a specific error, I would assert that if I get this error then it would be true.
	The other software testing technique that I used was integration testing, this is usually the second step on the testing ladder in front of unit testing. This is where we look at the software requirements and fit it against the code that we have written to look for compliance. This was done by me going through the code and seeing if it fit the rubric. 
	A testing technique that I did not use in the milestone is non-functional testing which includes performance and usability testing. This is where it is using the operational parts of the code instead of just focusing on the requirements. For instance, security testing is where you are testing things such as authorization and integrity in the code. Compatibility testing is another one that I did not use in the milestones as it involves trying the code in different environments and operating systems.
	The project that we worked on did not need all the non-functional testing and would be better suited on a project that involved a GUI or involved more people. For instance, if you had an app that a lot of people used, you would want to have a team do usability testing to make sure that there are not a lot of issues with navigating. 
	Unit testing allowed me to test the big methods and functionality that were mission-critical for our project. For instance, to make sure that the name and description in the tasks did not go over a certain character limit I made sure to make a unit test for just that case. With integration testing I go down line for line of the requirements to make sure that my code follows through with the requirements and my unit tests catch any of the problems that come from bugs.
      It is important that I used caution when testing and looking at the code because each object intertwined with other objects. You must appreciate the complexity as it can be confusing as to how an object uses another one and is important to understand this before going to using UnitTests. For instance, you have the service classes that use the regular object classes to form lists and perform mutations. You must use caution to make sure you allow these service classes to do what they need to do while keeping your original classes safe.
	Bias is important because people who write their own code tend to miss the errors that pile up. Therefore, it is important to have code revies where someone else looks at the code in terms of the security of the code and how it relates to the code requirements. This happens to even myself and is why it is important for other people to look at your code and review it, for instance when the professor looks at my code and gives feedback on how I can improve it.
	Lastly, it is important to stay disciplined in testing your code and continuing to follow the requirements set out by the committee. It is important to not cut corners as the testing phase is one of the most important parts of determining if your code is at the point it needs to be. By having a high coverage percentage, you are showing that you are testing a lot of your code. You can avoid technical debt by keeping your code lean and not adding more methods to do what your current methods already do.
